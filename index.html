<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>무한의 계단 — 소현이 · 채은이 · 채원이</title>
<style>
  :root{
    --bg1: #0f1724;
    --bg2: #042b34;
    --panel: rgba(255,255,255,0.06);
    --accent: #6ee7b7;
    --font: "Noto Sans KR", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;font-family:var(--font);background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef6;}
  .wrap{height:100%;display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px;box-sizing:border-box}
  header{width:100%;max-width:420px;display:flex;align-items:center;justify-content:space-between;gap:8px}
  h1{font-size:1.05rem;margin:0;color:var(--accent);letter-spacing:0.6px}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--panel);border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:10px;color:#dff7ee;cursor:pointer;font-weight:600}
  .small{padding:6px 8px;font-size:0.9rem;border-radius:8px}
  #hud{display:flex;gap:8px;align-items:center}
  #scoreBoard{font-weight:700;color:#fff9;margin-right:6px}
  #high{font-size:0.85rem;opacity:0.8}

  /* canvas area */
  .game-area{width:100%;max-width:420px;flex:1;display:flex;align-items:center;justify-content:center;position:relative}
  canvas{width:100%;height:100%;border-radius:12px;box-shadow:0 12px 40px rgba(2,8,23,0.6);background:linear-gradient(180deg,#082226,#05202a)}

  /* bottom HUD & selection */
  .bottom-ui{width:100%;max-width:420px;display:flex;gap:10px;align-items:center;justify-content:space-between;padding-top:8px}
  .character-select{display:flex;gap:8px}
  .char{
    width:56px;height:56px;border-radius:10px;background:var(--panel);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border:2px solid transparent;transition:transform .12s, border-color .12s;
  }
  .char.selected{transform:translateY(-6px);border-color:rgba(110,231,183,0.9);box-shadow:0 6px 18px rgba(110,231,183,0.08)}
  .char small{display:block;font-size:11px;opacity:0.95;margin-top:4px;color:#e9fdf0}
  .legend{font-size:13px;color:rgba(255,255,255,0.85)}

  /* touch controls */
  .touch-controls{position:fixed;right:12px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:40}
  .touch-row{display:flex;gap:8px}
  .tbtn{width:58px;height:58px;border-radius:12px;background:linear-gradient(180deg,#ffffff08,#00000006);border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;box-shadow:0 8px 18px rgba(0,0,0,0.25);touch-action:manipulation}
  .hint{position:fixed;left:12px;bottom:18px;background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;font-size:13px;color:rgba(255,255,255,0.85)}
  footer{font-size:12px;color:rgba(255,255,255,0.55);margin-top:6px}
  @media (max-width:420px){
    .char{width:48px;height:48px}
    .tbtn{width:52px;height:52px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>무한의 계단 — 올라가라, 영원히</h1>
      <div class="controls">
        <div id="scoreBoard">높이: <span id="score">0</span>m</div>
        <div id="high" title="최고 기록">최고: <span id="best">0</span>m</div>
        <button class="btn small" id="restartBtn">다시 시작⟲</button>
      </div>
    </header>

    <div class="game-area">
      <canvas id="gameCanvas" width="420" height="700"></canvas>
    </div>

    <div class="bottom-ui">
      <div class="character-select" title="캐릭터 선택">
        <div class="char selected" data-id="0" id="char0" role="button" aria-pressed="true">
          <div style="width:34px;height:34px;border-radius:6px;background:#ff8a80;display:flex;align-items:center;justify-content:center;color:#2a0b06;font-weight:800">소</div>
          <small>소현</small>
        </div>
        <div class="char" data-id="1" id="char1" role="button">
          <div style="width:34px;height:34px;border-radius:6px;background:#80d8ff;display:flex;align-items:center;justify-content:center;color:#042134;font-weight:800">채</div>
          <small>채은</small>
        </div>
        <div class="char" data-id="2" id="char2" role="button">
          <div style="width:34px;height:34px;border-radius:6px;background:#b39ddb;display:flex;align-items:center;justify-content:center;color:#29133d;font-weight:800">원</div>
          <small>채원</small>
        </div>
      </div>

      <div class="legend">컨트롤: 좌/우 화살표 / A D • 모바일: 화면 터치 또는 하단 버튼</div>
    </div>

    <footer>© 간단 게임 — 즐겁게 플레이하세요!</footer>
  </div>

  <div class="touch-controls" id="touchControls" style="display:none">
    <div class="touch-row">
      <button class="tbtn" id="leftBtn">◀</button>
      <button class="tbtn" id="jumpBtn">▲</button>
      <button class="tbtn" id="rightBtn">▶</button>
    </div>
  </div>

<script>
/* =========================
   무한의 계단 — single file
   - 플레이어 3명(선택 가능)
   - 끝없이 위로 생성되는 계단(플랫폼)
   - 좌우 이동, 착지하면 자동으로 뛰어오름 (스프링 효과)
   - 높이(점수), 최고기록 저장 (localStorage)
   - 모바일 터치 컨트롤 지원
   ========================= */

/* ---------- 설정 ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize() {
  // keep logical size constant while scaling for crisp rendering
  const rect = canvas.getBoundingClientRect();
  canvas.width = canvas.clientWidth * DPR;
  canvas.height = canvas.clientHeight * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
function fitCanvas() {
  // ensure canvas CSS size fits container
  const wrap = canvas.parentElement;
  const maxW = Math.min(420, window.innerWidth - 24);
  const maxH = Math.min(820, window.innerHeight - 160);
  // maintain portrait aspect
  canvas.style.width = maxW + 'px';
  canvas.style.height = maxH + 'px';
  resize();
}
window.addEventListener('resize', ()=>{ DPR = window.devicePixelRatio || 1; fitCanvas(); });
fitCanvas();

/* world */
const W = canvas.width / DPR;
const H = canvas.height / DPR;
let viewWidth = canvas.clientWidth;
let viewHeight = canvas.clientHeight;

/* gameplay params */
const GRAVITY = 0.45;
const FRICTION = 0.98;
const PLATFORM_W_MIN = 60;
const PLATFORM_W_MAX = 160;
const PLATFORM_GAP_MIN = 48;
const PLATFORM_GAP_MAX = 90;

/* characters (소현, 채은, 채원) */
const CHARACTERS = [
  { name:'소현', color:'#ff8a80', size:32, jumpBoost:1.06, speed:3.2, icon:'소' },
  { name:'채은', color:'#80d8ff', size:32, jumpBoost:1.0, speed:3.6, icon:'채' },
  { name:'채원', color:'#b39ddb', size:34, jumpBoost:0.96, speed:3.0, icon:'원' }
];

/* state */
let game = null;

/* DOM */
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const restartBtn = document.getElementById('restartBtn');
const charEls = document.querySelectorAll('.char');
const touchControls = document.getElementById('touchControls');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const jumpBtn = document.getElementById('jumpBtn');

/* input */
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* touch UI show on touch devices */
if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
  touchControls.style.display = 'flex';
}

/* character selection */
let selectedCharIndex = 0;
charEls.forEach(el=>{
  el.addEventListener('click', ()=>{
    charEls.forEach(c=>c.classList.remove('selected'));
    el.classList.add('selected');
    selectedCharIndex = Number(el.dataset.id);
    // restart with new character
    startGame();
  });
});

/* restart */
restartBtn.addEventListener('click', ()=> startGame());

/* touch buttons */
let touchLeft=false, touchRight=false, touchJump=false;
leftBtn.addEventListener('pointerdown', ()=> touchLeft=true);
leftBtn.addEventListener('pointerup', ()=> touchLeft=false);
leftBtn.addEventListener('pointercancel', ()=> touchLeft=false);
rightBtn.addEventListener('pointerdown', ()=> touchRight=true);
rightBtn.addEventListener('pointerup', ()=> touchRight=false);
rightBtn.addEventListener('pointercancel', ()=> touchRight=false);
jumpBtn.addEventListener('pointerdown', ()=> touchJump=true);
jumpBtn.addEventListener('pointerup', ()=> touchJump=false);
jumpBtn.addEventListener('pointercancel', ()=> touchJump=false);

/* -------------------------------------------------------------------------
   World & Platform generation
   platforms array holds objects {x,y,w,h,type,dx}
   y increases downward; player moves up so we generate platforms with
   decreasing y values (smaller y = higher on screen)
   ------------------------------------------------------------------------- */

function makePlatform(x,y,w,type='normal'){
  return { x, y, w, h:12, type, dx: (type==='moving'? (Math.random()<0.5?1.2:-1.2) : 0) };
}

/* generate initial platforms */
function generateInitialPlatforms(){
  const arr = [];
  const startY = canvas.clientHeight - 80;
  // base platform under player
  arr.push(makePlatform( (canvas.clientWidth/2)-80, startY, 160, 'base'));
  // upward platforms
  let y = startY - 40;
  while(y > -2000){
    const w = Math.floor(Math.random()*(PLATFORM_W_MAX-PLATFORM_W_MIN))+PLATFORM_W_MIN;
    const x = Math.floor(Math.random()*(canvas.clientWidth - w - 20)) + 10;
    const typeRand = Math.random();
    const type = typeRand < 0.08 ? 'moving' : (typeRand < 0.14 ? 'break' : 'normal');
    arr.push(makePlatform(x, y, w, type));
    y -= (Math.random()*(PLATFORM_GAP_MAX-PLATFORM_GAP_MIN) + PLATFORM_GAP_MIN);
  }
  return arr;
}

/* -------------------------------------------------------------------------
   Player object
   ------------------------------------------------------------------------- */
function makePlayer(charIndex){
  const ch = CHARACTERS[charIndex];
  return {
    charIndex,
    x: canvas.clientWidth/2,
    y: canvas.clientHeight - 140,
    vx:0, vy:0,
    w: ch.size * 0.9, h: ch.size * 1.1,
    color: ch.color,
    jumpBoost: ch.jumpBoost,
    speed: ch.speed,
    landed: false,
    fallStartY: 0
  };
}

/* -------------------------------------------------------------------------
   Core game start / loop
   ------------------------------------------------------------------------- */
function startGame(){
  fitCanvas();
  const best = Number(localStorage.getItem('infiniteStairsBest') || 0);
  bestEl.textContent = best;
  // initial state
  game = {
    player: makePlayer(selectedCharIndex),
    platforms: generateInitialPlatforms(),
    offsetY: 0,     // how much world has scrolled up (pixels)
    score: 0,
    alive: true,
    time: 0
  };
  // place player on base platform center
  const base = game.platforms[0];
  game.player.x = base.x + base.w/2;
  game.player.y = base.y - game.player.h - 2;
  game.player.vx = 0; game.player.vy = 0;
  game.player.landed = true;
  game.player.fallStartY = game.player.y;
  scoreEl.textContent = '0';
}

/* collision detection: check if player is standing on a platform */
function checkPlatformCollision(p, platforms){
  // simple AABB: check downward movement intersects platform top
  const futureY = p.y + p.vy;
  for(let i=0;i<platforms.length;i++){
    const plat = platforms[i];
    const top = plat.y;
    const left = plat.x;
    const right = plat.x + plat.w;
    // if player's bottom crosses platform top and horizontally overlaps
    const playerBottom = futureY + p.h;
    const prevBottom = p.y + p.h;
    if(prevBottom <= top && playerBottom >= top){
      const playerLeft = p.x;
      const playerRight = p.x + p.w;
      if(playerRight > left + 6 && playerLeft < right - 6){
        return { hit:true, platIndex:i };
      }
    }
  }
  return { hit:false, platIndex:-1 };
}

/* remove distant platforms and generate more above as needed */
function maintainPlatforms(){
  // remove platforms way below view
  const threshold = game.offsetY + canvas.clientHeight + 200;
  game.platforms = game.platforms.filter(pl => pl.y > (game.offsetY - 2000) && pl.y < (game.offsetY + canvas.clientHeight + 600));
  // ensure there are always platforms up to a certain negative Y
  let minY = Infinity;
  for(const pl of game.platforms) if(pl.y < minY) minY = pl.y;
  while(minY > -6000){
    const w = Math.floor(Math.random()*(PLATFORM_W_MAX-PLATFORM_W_MIN))+PLATFORM_W_MIN;
    const x = Math.floor(Math.random()*(canvas.clientWidth - w - 20)) + 10;
    const y = minY - (Math.random()*(PLATFORM_GAP_MAX-PLATFORM_GAP_MIN) + PLATFORM_GAP_MIN);
    const typeRand = Math.random();
    const type = typeRand < 0.07 ? 'moving' : (typeRand < 0.12 ? 'break' : 'normal');
    game.platforms.push(makePlatform(x, y, w, type));
    minY = y;
  }
}

/* apply physics and update world */
function update(dt){
  if(!game.alive) return;

  const p = game.player;

  // input
  let moveLeft = keys['arrowleft'] || keys['a'] || touchLeft;
  let moveRight = keys['arrowright'] || keys['d'] || touchRight;
  if(touchLeft) moveLeft = true;
  if(touchRight) moveRight = true;
  // combine touch and keyboard jump
  const wantsJump = keys[' '] || keys['w'] || keys['arrowup'] || touchJump;

  // horizontal move
  if(moveLeft && !moveRight) p.vx = -p.speed;
  else if(moveRight && !moveLeft) p.vx = p.speed;
  else p.vx *= FRICTION;

  // gravity
  p.vy += GRAVITY;

  // predicted position
  p.x += p.vx;
  p.y += p.vy;

  // wrap around sides
  if(p.x + p.w < 0) p.x = canvas.clientWidth;
  if(p.x > canvas.clientWidth) p.x = -p.w;

  // check collisions only when falling (vy > 0)
  if(p.vy >= 0){
    const resp = checkPlatformCollision(p, game.platforms);
    if(resp.hit){
      const plat = game.platforms[resp.platIndex];
      // land
      p.y = plat.y - p.h - 0.1;
      p.vy = -10 * p.jumpBoost; // automatic powerful bounce upward
      // small variations for break or moving
      if(plat.type === 'break'){
        // break after landing => remove platform
        // make a small delay before removal to allow bounce
        setTimeout(()=> {
          const idx = game.platforms.indexOf(plat);
          if(idx>=0) game.platforms.splice(idx,1);
        }, 80);
      }
      // if moving platform, adjust x
      if(plat.type === 'moving'){
        p.x += plat.dx * 1.2;
      }
      // sound feedback
      playTone(260 + Math.random()*80, 0.05);
    }
  }

  // moving platforms update
  for(const pl of game.platforms){
    if(pl.type === 'moving'){
      pl.x += pl.dx;
      if(pl.x <= 6 || pl.x + pl.w >= canvas.clientWidth - 6) pl.dx *= -1;
    }
  }

  // Scroll world upward if player is above upper threshold
  const topThreshold = canvas.clientHeight * 0.36;
  if(p.y < topThreshold){
    // shift world down relative to player to create upward motion illusion
    const shift = (topThreshold - p.y);
    game.offsetY += shift;
    p.y += shift;
    for(const pl of game.platforms) pl.y += shift;
    // score increases by shift amount (convert to meters approx)
    game.score = Math.max(game.score, Math.floor(game.offsetY * 0.6));
    scoreEl.textContent = game.score;
  }

  // lose condition: falling below bottom of screen by large margin
  if(p.y > canvas.clientHeight + 120){
    game.alive = false;
    // update best
    const best = Number(localStorage.getItem('infiniteStairsBest') || 0);
    if(game.score > best) localStorage.setItem('infiniteStairsBest', String(game.score));
    bestEl.textContent = Math.max(best, game.score);
    // small buzz
    playTone(120, 0.2);
  }

  // maintain platforms
  maintainPlatforms();
}

/* -------------------------------------------------------------------------
   Rendering
   ------------------------------------------------------------------------- */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

  // subtle background gradient
  const g = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
  g.addColorStop(0,'#032b2a'); g.addColorStop(1,'#01181a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

  // distant parallax shapes (faint)
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  for(let i=0;i<6;i++){
    const rx = (i*123 + (game ? (game.offsetY*0.2) : 0)) % canvas.clientWidth;
    ctx.fillRect(rx, 40 + i*38, 120, 8);
  }

  // draw platforms
  for(const pl of game.platforms){
    // skip platforms far below/above for performance
    if(pl.y > canvas.clientHeight + 200 || pl.y < -1200) continue;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.fillRect(pl.x + 4, pl.y + 6, pl.w, pl.h);
    // platform body
    if(pl.type === 'normal'){
      ctx.fillStyle = '#7b5e57';
      roundRect(ctx, pl.x, pl.y, pl.w, pl.h, 4, true, false);
      ctx.fillStyle = '#d0b8a8';
      ctx.fillRect(pl.x+6, pl.y+2, Math.max(8, pl.w-12), 3);
    } else if(pl.type === 'moving'){
      ctx.fillStyle = '#5b8a7b';
      roundRect(ctx, pl.x, pl.y, pl.w, pl.h, 6, true, false);
      ctx.fillStyle = '#bfe9d6';
      ctx.fillRect(pl.x+6, pl.y+2, Math.max(8, pl.w-12), 3);
    } else if(pl.type === 'break'){
      ctx.fillStyle = '#a86b6b';
      roundRect(ctx, pl.x, pl.y, pl.w, pl.h, 4, true, false);
      // crack lines
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.beginPath();
      ctx.moveTo(pl.x+8, pl.y+2); ctx.lineTo(pl.x+pl.w-8, pl.y+pl.h-2);
      ctx.stroke();
    } else if(pl.type === 'base'){
      ctx.fillStyle = '#3b5950';
      roundRect(ctx, pl.x, pl.y, pl.w, pl.h, 6, true, false);
    }
  }

  // draw player
  const p = game.player;
  // drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(p.x + p.w/2, p.y + p.h + 6, p.w*0.9, 8, 0, 0, Math.PI*2);
  ctx.fill();
  // body
  ctx.fillStyle = p.color;
  roundRect(ctx, p.x, p.y, p.w, p.h, 6, true, false);
  // face (simple)
  ctx.fillStyle = '#2b2b2b';
  ctx.fillRect(p.x + p.w*0.2, p.y + p.h*0.25, 3, 3);
  ctx.fillRect(p.x + p.w*0.7, p.y + p.h*0.25, 3, 3);
  // name tag
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = '12px sans-serif';
  ctx.fillText( CHARACTERS[p.charIndex].name, p.x - 6, p.y - 8);

  // if game over, overlay message
  if(!game.alive){
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    ctx.fillStyle = '#fff';
    ctx.font = '28px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('게임 오버', canvas.clientWidth/2, canvas.clientHeight/2 - 10);
    ctx.font = '16px sans-serif';
    ctx.fillText(`최종 높이: ${game.score}m`, canvas.clientWidth/2, canvas.clientHeight/2 + 18);
    ctx.textAlign = 'start';
  }
}

/* utility: rounded rect */
function roundRect(ctx,x,y,w,h,r, fill, stroke){
  if(typeof r === 'undefined') r = 6;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* -------------------------------------------------------------------------
   Audio: tiny beep using WebAudio for feedback
   ------------------------------------------------------------------------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio(){
  if(!audioCtx){
    audioCtx = new AudioCtx();
  }
}
function playTone(freq, dur){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.value = 0.02;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.stop(audioCtx.currentTime + dur + 0.02);
  }catch(e){}
}

/* -------------------------------------------------------------------------
   Main loop
   ------------------------------------------------------------------------- */
let last = performance.now();
function loop(now){
  if(!game) return;
  const dt = now - last;
  last = now;

  // translate touch inputs into keys
  if(touchLeft) keys['a']=true; else if(!keys['arrowleft']) keys['a']=false;
  if(touchRight) keys['d']=true; else if(!keys['arrowright']) keys['d']=false;
  // jump via touch:
  if(touchJump){
    // micro-press logic: only if near platform or falling small
    const p = game.player;
    // allow manual strong jump when on/near platform
    if(p.vy > -6 && p.vy < 6){
      p.vy = -10 * p.jumpBoost;
      playTone(420, 0.06);
    }
    touchJump = false; // single jump per tap
  }

  update(dt);
  draw();

  requestAnimationFrame(loop);
}

/* initialize */
startGame();
last = performance.now();
requestAnimationFrame(loop);

/* -------------------------------------------------------------------------
   Mouse / touch direct jump: tap to nudge player horizontally toward pointer
   Also, allow dragging to move player horizontally
   ------------------------------------------------------------------------- */
let dragging=false;
canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  if(e.pointerType === 'mouse'){
    // left click -> jump towards x
    const p = game.player;
    const dir = mx < p.x ? -1 : 1;
    p.vx = dir * p.speed * 1.2;
    p.vy = -10 * p.jumpBoost;
    playTone(380, 0.06);
  } else {
    dragging = true;
    // set pointer capture for continuous moves
    canvas.setPointerCapture(e.pointerId);
  }
});
canvas.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  // set player's x to follow finger (but gently)
  const p = game.player;
  const targetX = mx - p.w/2;
  p.x += (targetX - p.x) * 0.25;
});
canvas.addEventListener('pointerup', e=>{
  dragging = false;
  try{ canvas.releasePointerCapture(e.pointerId); }catch(err){}
});

/* -------------------------------------------------------------------------
   Keep high score visible and update periodically
   ------------------------------------------------------------------------- */
setInterval(()=>{
  const best = Number(localStorage.getItem('infiniteStairsBest') || 0);
  bestEl.textContent = best;
}, 1000);

/* Prevent context menu on long touch */
canvas.addEventListener('contextmenu', e=> e.preventDefault());
</script>
</body>
</html>
